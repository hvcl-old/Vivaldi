###########################################################################################
def minimum(volume, x, y, z):
	# Specify the radius here
	radius = 2            
	cube_iter = make_cube_iter(x, y, z, radius)
	
	center = make_float3(x,y,z) 
	min = point_query_3d(volume, center)
	for point in cube_iter:
		pointVal = point_query_3d(volume, point)
		if min > pointVal:
			min = pointVal 
		
	return min
###########################################################################################
def conditional_minimum(volume, x, y, z, thresh):
	# Specify the radius here
	radius = 2            
	cube_iter = make_cube_iter(x, y, z, radius)
	center = make_float3(x,y,z) 
	min = point_query_3d(volume, center)
	for point in cube_iter:
		pointVal = point_query_3d(volume, point)
		if min > pointVal:
			min = pointVal
    
    condition = False
    threshold = 30 # Cang lon cang ro~
        
    centerVal = point_query_3d(volume, center)
    
    if centerVal < threshold:
        condition = True
        
	if condition:	
        return min
    else:
        return centerVal/2
###########################################################################################
def maximum(volume, x, y, z):
	# Specify the radius here
	radius = 3            

	cube_iter = make_cube_iter(x, y, z, radius)
	
	center = make_float3(x,y,z) 
	max= point_query_3d(volume, center)
	for point in cube_iter:
		pointVal = point_query_3d(volume, point)
		if max < pointVal:
			max = pointVal
		
	return max

###########################################################################################
def conditional_maximum(volume, x, y, z):
	# Specify the radius here
	radius = 2            

	cube_iter = make_cube_iter(x, y, z, radius)
	
	center = make_float3(x,y,z) 
	max= point_query_3d(volume, center)
	for point in cube_iter:
		pointVal = point_query_3d(volume, point)
		if max < pointVal:
			max = pointVal
            
	 
    condition = False
    threshold = 10 # Cang lon cang ro~
        
    centerVal = point_query_3d(volume, center)
    
    if centerVal > threshold:
        condition = True
        
	if condition:	
        return max
    else:
        return centerVal
###########################################################################################
def median(volume, x, y, z):
    # Viola's method
	minval = 0
    maxval = 255
    pivot  = (minval + maxval)/2.0
	
	count 	= 0
	val 	= 0
	for trial in range(0, 8):
		radius = 3       
		cube_iter = make_cube_iter(x, y, z, radius)
		count 	= 0
		for point in cube_iter:
			val = point_query_3d(volume, point)
			if val > pivot:
				count = count + 1

		if count < (2*radius+1)*(2*radius+1)*(2*radius+1)/2:
			maxval = floorf(pivot);      
        else:
            minval = floorf(pivot)+1;
	
		pivot = (minval + maxval)/2.0;

	return floorf(pivot)
    
###########################################################################################
def standard_deviation(volume, x, y, z):
	# Specify the radius here
	radius = 3            
	cube_iter = make_cube_iter(x, y, z, radius)

	# Calculate the average
	sum = 0
	total = 0
	for point in cube_iter:
		sum = sum + point_query_3d(volume, point)
		total += 1

	mean = sum/(total)

	# Calculate the population
	cube_iter = make_cube_iter(x,y,z, radius)
	tmp   = 0
	stdev = 0
	for point in cube_iter:
		tmp = point_query_3d(volume, point) - mean
		stdev += sqrt(tmp*tmp)

	# Calculate the standard deviation
	stdev /= mean
	stdev = sqrt(stdev)
	
	return stdev


###########################################################################################
def to_float(volume, x, y, z):
	center = make_float3(x,y,z) 
	val = point_query_3d(volume, center)
	return val
###########################################################################################
def bilateral(volume, x, y, z):
    center      = make_float3(x,y,z) 
	centerVal   = point_query_3d(volume, center)
	# Specify the radius here
	radius = 5            
	cube_iter = make_cube_iter(x, y, z, radius)
    
    id              = 5 #10 #100 # 1000 # 0.01
    imageWeight 	= 1
    
    cd              = 2 #5
    colorWeight     = 1  
    weight          = 0
    totalWeight     = 0

    count           = 0
    pointVal        = 0
    
    out = 0;
    for point in cube_iter:
        pointVal = point_query_3d(volume, point)                                      
        imageWeight	= expf(-0.5* ((center.x-point.x)*(x-point.x) + (center.y-point.y)*(center.y-point.y) + (center.z-point.z)*(center.z-point.z) ) / (id*id))
        colorWeight = expf(-0.5* ((centerVal-pointVal)*(centerVal-pointVal) ) / (cd*cd))
        weight = imageWeight * colorWeight
        out    = out + weight*pointVal
        totalWeight = totalWeight + weight
        count = count + 1
    out = out/totalWeight
    
    return out
###########################################################################################
def surface_detection(volume, x, y, z):
	dif = linear_gradient_3d(volume, x, y, z)
    
    # dif = length(dif)
    # # if dif > 1:
        # # dif = 1
    return length(dif)
    # if length(dif) > .2: 
        # return 0
	# return 1
###########################################################################################
def threshold(volume, x, y, z):
     
	center      = make_float3(x,y,z) 
	centerVal   = point_query_3d(volume, center)
	    
    ## Calculate mean
    radius    = 5
    pointVal  = 0
    cube_iter = make_cube_iter(x, y, z, radius)
    sum       = 0
    total     = 0
    for point in cube_iter:
        pointVal = point_query_3d(volume, point)
        sum   = sum   + pointVal
		total = total + 1
    mean = sum/total
    
    thresh = 1.8 #2.0 #1.8
    if mean < thresh:
        return 1
    else:
        return 0
    # return thresh
    # ## Calculate stdevev
    # # Calculate the population
	# cube_iter = make_cube_iter(x,y,z, radius)
	# tmp   = 0
	# stdev = 0
	# for point in cube_iter:
		# tmp = point_query_3d(volume, point) - mean
		# stdev += sqrt(tmp*tmp)

	# # Calculate the standard deviation
	# stdev /= mean
	# stdev = sqrt(stdev)
    
    # ####################
    # k = 0
    # r = 0.5
    # p = 2
    # q = 10
    
    # # Phansalkar's method http://fiji.sc/wiki/index.php/Auto_Local_Threshold
    # # t = mean * (1 + p * exp(-q * mean) + k * ((stdevev / r) - 1)) 
    # thresh = 0
    # thresh = mean * (1 + p * expf(-q * mean) + k * ((stdev / r) - 1))
    
    # # if centerVal < thresh:
        # # return 1
    # # else:
        # # return 0
    # return thresh
###########################################################################################
def connectedcomponent(segmentation, label, x, y, z):
	radius = 1
	# Currently test for connected component = 26
	conn = 26
	
	cube_iter = make_cube_iter(x, y, z, radius)
	
	centerVal 	= 0
	minVal 		= 0
	pointVal	= 0
	
	center 		= make_float3(x,y,z) 
	
	centerVal 	= point_query_3d(segmentation, center)
	minVal 		= point_query_3d(label, center)
	
	
	if centerVal>0:
		connetedVal 	= 0
		for point in cube_iter:
			connectedVal 	= point_query_3d(segmentation, point)
			pointVal 		= point_query_3d(label, point)
			if connectedVal > 0 and minVal > pointVal:
				minVal = pointVal 

	return minVal
###########################################################################################
def overlay(v1, v2, x, y, z):
	val1	= 0
	val2	= 0
	
		
	val1 	= point_query_3d(v1, x, y, z)
	val2	= point_query_3d(v2, x, y, z)

	return val1*val2
###########################################################################################

import numpy
def main():           
    ## Test read and write uchar -> float
    volume = load_data_3d('/home/shared/data/em_small.dat', 'uchar')
    # volume = to_float(volume,x,y,z).range(volume).dtype(volume, uchar)
    # save_image(volume,'result.raw', out_of_core=True)
   
#	volume = median(volume,x,y,z).range(volume).dtype(volume, uchar)
	volume = median(volume,x,y,z).range(volume).dtype(volume, uchar).split(volume,z=4).halo(volume,3)
	volume = standard_deviation(volume,x,y,z).range(volume).dtype(volume, float)
	volume = bilateral(volume,x,y,z).range(volume).dtype(volume, float)
	volume = minimum(volume,x,y,z).range(volume).dtype(volume, float) #erosion filter
	volume = threshold(volume,x,y,z).range(volume).dtype(volume, float)

	
	# Initialize the labeling
	# label = numpy.random.rand(volume.shape).astype(numpy.float32)
	
	# print "Initialize the labeling"
	# label = numpy.linspace(0, volume.size, num=volume.size, endpoint=True).astype(numpy.float32)
	# label = numpy.reshape(label, (512, 512, 512))
	
	# for k in range(0, 100):
		# label = connectedcomponent(volume, label, x, y, z).range(volume).dtype(volume, float).dtype(label, float)
	
	# label = overlay(volume, label, x, y, z).range(volume).dtype(volume, float).dtype(label, float)
	
	
	
		# label = connectedcomponent(volume, label, x, y, z).modifier(label, size=label, dtype=float)
	# ## TODO: Debug here
    # # 3D Median filter
    # volume = median(volume,x,y,z).range(volume).dtype(volume, float)

    # # 3D Standard Deviation
    # volume = standard_deviation(volume,x,y,z).range(volume).dtype(volume, float)
	# volume = minimum(volume,x,y,z).range(volume).dtype(volume, float)
    
	# volume = bilateral(volume,x,y,z).range(volume).dtype(volume, float)
    # volume = bilateral(volume,x,y,z).range(volume).dtype(volume, float)
    # volume = bilateral(volume,x,y,z).range(volume).dtype(volume, float)
    # volume = median(volume,x,y,z).range(volume).dtype(volume, float)
    # volume = threshold(volume,x,y,z).range(volume).dtype(volume, float)
    # volume = maximum(volume,x,y,z).range(volume).dtype(volume, float)
    # volume = minimum(volume,x,y,z).range(volume).dtype(volume, float)
   
    # volume = maximum(volume,x,y,z).range(volume).dtype(volume, float)
    # volume = maximum(volume,x,y,z).range(volume).dtype(volume, float)
    # volume = bilateral(volume,x,y,z).range(volume).dtype(volume, float)
    
    # volume = threshold(volume,x,y,z).range(volume).dtype(volume, float)
    # # print volume[2:8,2:8:,2:8]
	
    # # volume = conditional_minimum(volume,x,y,z).range(volume).dtype(volume, float)
    # # volume = conditional_maximum(volume,x,y,z).range(volume).dtype(volume, float)
    # # volume = conditional_maximum(volume,x,y,z).range(volume).dtype(volume, float)
    # # volume = conditional_maximum(volume,x,y,z).range(volume).dtype(volume, float)
    
    # # for trial in range(0, 10)
    # # volume = maximum(volume,x,y,z).range(volume).dtype(volume, float)
    # # volume = minimum(volume,x,y,z).range(volume).dtype(volume, float)

    
    # # volume = bilateral(volume,x,y,z).range(volume).dtype(volume, float)
    # # volume = surface_detection(volume,x,y,z).range(volume).dtype(volume, float)
    
    
    # # volume = minimum(volume,x,y,z).range(volume).dtype(volume, float)
    # # volume = minimum(volume,x,y,z).range(volume).dtype(volume, float)
    # # volume = maximum(volume,x,y,z).range(volume).dtype(volume, float)
    # # volume = maximum(volume,x,y,z).range(volume).dtype(volume, float)
    
#	synchronize()   
	# Save as float
	save_image(volume,'result.raw') 
	# save_image(label,'result.raw') 
    
###########################################################################################
if __name__ == '__main__':     # if the function is the main function ...
    main() # ...call it
