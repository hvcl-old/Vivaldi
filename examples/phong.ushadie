def mip(volume, x, y):
	step = 0.4                      
	line_iter = orthogonal_iter(volume, x, y, step)
	D = make_float3(0)
	D = line_iter.direction()
	T = 1300 * 2

	ambient = make_float3(0.05)
	lightpos1 = make_float3( -800, -800, 0)
	lightpos2 = make_float3( 300, -100, 0)
	#lightpos2 = make_float3( 0, 0, 550)
	
	for elem in line_iter:
		temp = cubic_query_3d(volume, elem)-T
		if temp > 0:
			P = elem
			Q = P
			P = P - step * D

			while length(P - Q) >  0.0001:
				M = make_float3(0)
				M = (P + Q) / 2
				f = linear_query_3d(volume, M) - T
				if f < 0:
					P = M
				else:
					Q = M

			color1 = make_float3(225.0/255,73.0/255,15.0/255)
			color2 = make_float3(1,1,1)
			#color1 = make_float3(transfer(50)/255)
			#color2 = make_float3(transfer_ch2(50)/255)
			tmp_pq = make_float3(0)
			tmp_pq = (P+Q)/2
			N = make_float3(0)
			N = normalize(cubic_gradient_3d(volume,tmp_pq))
			N = -N
#			N = -(normalize(cubic_gradient_3d(volume,(P+Q)/2)))
			
			L1 = normalize(lightpos1 - P)
			L2 = normalize(lightpos2 - P)

			# accumulate
			#result1 = phong(L1, N, -D, color1, make_float3(1), 20, ambient)*255
			#result2 = phong(L2, N, -D, color2, make_float3(1), 20, ambient)*255

			result1 = diffuse(L1, N, color1)*255
			result2 = diffuse(L2, N, color2)*255
			#result2 = diffuse(L2, N, color2)*255
			return RGB(result1 + result2)

		
	return RGB(make_float3(255))
							  
def main():                                                                         
	volume = load_data_3d(DATA_PATH+'/CThead.dat')

	result = mip(volume, x, y).range(x=-512:512,y=-512:512).dtype(volume, short)
	save_image(result)
